# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['Data']

# %% ../nbs/00_core.ipynb 3
import logging
from copy import deepcopy
from textwrap import indent
from collections import ChainMap
from typing import Any, Generator, Sequence, Optional

# %% ../nbs/00_core.ipynb 8
class Data:
    """
    Data holder used during code generation. Logic is kept as separate functions.
    """

    parent: Optional["Data"]
    children: Sequence["Data"]

    def __init__(
        self,
        name: str,  # Name of this element
        attrs: Optional[dict[str, Any]] = None,  # Attributes for this element
    ) -> None:
        """
        Initialize Data object.

        """

        self.name = name
        # TODO accept parent directly in init?
        self.parent: Optional["Data"] = None
        self.children: Sequence["Data"] = []

        # we don't directly store them because the final attributes are
        # composed by the attributes of itself and its parents.
        self._attrs = {} if attrs is None else attrs

    @property
    def attrs(self) -> ChainMap:
        """
        Get the attributes for this element, merged with
        parent's attributes, if available.
        """
        if self.parent:
            return ChainMap(self._attrs, self.parent.attrs)
        return ChainMap(self._attrs)

    def clone(self) -> "Data":
        """
        Create a deep copy of this Data object.

        """
        return deepcopy(self)

    def append(self, child: "Data") -> "Data":
        """
        Add a child element to the children list and set its parent to self.
        """
        self.children.append(child)  # type: ignore[attr-defined]
        child.set_parent(self)
        return child

    def set_parent(self, parent: "Data") -> None:
        """
        Set the parent element of self.
        """
        logging.info("Setting parent %s for %s", parent, self)
        self.parent = parent

    def __eq__(self, a: Any) -> bool:
        """
        Compare this Data object with another object for equality.

        """
        same_name: bool = self.name == a.name
        same_attrs: bool = self.attrs == a.attrs
        same_children: bool = self.children == a.children
        return same_name and same_attrs and same_children

    def as_tree(self) -> str:
        """
        Get the string representation of this Data object.

        """
        is_self_closing = not self.children

        if self.children:
            children = "\n".join(map(str, self.children))
            children = children.strip()
            children = f"\n{children}\n"
            children = indent(children, "    ")

        if self.attrs:
            if is_self_closing:
                return f"<{self.name} {dict(self.attrs)} />"
            else:
                return f"<{self.name} {dict(self.attrs)}>{children}</{self.name}>"

        if is_self_closing:
            return f"<{self.name} />"
        else:
            return f"<{self.name}>{children}</{self.name}>"

    def __str__(self) -> str:
        return f"[{self.name} {dict(self.attrs)}]"

    def __len__(self) -> int:
        return len(self.children)

    def __contains__(self, child: "Data") -> bool:
        return child in self.children

    def __iter__(self) -> Generator:
        def iter_data(obj: "Data", level: Optional[int] = 0) -> Generator:
            """Simply yields parent and then children"""
            yield obj, level
            for child in obj.children:
                yield from iter_data(child, level=(level or 0) + 1)

        return iter_data(self)

    __repr__ = as_tree
