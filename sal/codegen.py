# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_codegen.ipynb.

# %% auto 0
__all__ = ['Config', 'Sal']

# %% ../nbs/02_codegen.ipynb 3
import abc
from pydantic import BaseModel
from typing import Any, Callable
from dataclasses import dataclass
from pathlib import Path
from textwrap import dedent
from typing import Optional

from .core import Data
from .loaders import xml_file_to_data
from sal.templates import (
    Renderer,
    TemplateLoader,
    TemplateRenderer,
    MissingTemplateException,
)

# %% ../nbs/02_codegen.ipynb 12
@dataclass
class WriteFileResult:
    to: str
    content: str


class SalAction(abc.ABC):
    @property
    @abc.abstractmethod
    def name(self) -> str:
        pass

    @abc.abstractmethod
    def process_data(
        self, sal: "Sal", data: Data
    ) -> tuple[str, Optional[WriteFileResult]]:
        pass

    def __str__(self) -> str:
        return f"action:{self.name}"


class ToFileAction(SalAction):
    name = "to-file"

    def process_data(self, sal: "Sal", data: Data) -> tuple[str, WriteFileResult]:
        rendered = sal.renderer.render(data, template=Renderer.DEFAULT_TEMPLATE)

        if "to" not in data.attrs:
            raise RuntimeError(
                "To save to file you need to define the 'to' attribute with a filepath"
            )
        to = data.attrs["to"]

        return rendered, WriteFileResult(to=to, content=rendered)


class GroupAction(SalAction):
    name = "group"

    def process_data(self, sal: "Sal", data: Data) -> tuple[Any, None]:
        return [sal.process(d) for d in data.children], None

# %% ../nbs/02_codegen.ipynb 13
class Config(BaseModel):
    template_directories: list[Path]
    filters: dict[str, Callable] = {}


class Sal:
    def __init__(self, config: Config, renderer: Renderer):
        self.config = config
        self.renderer = renderer
        self.actions = [ToFileAction(), GroupAction()]  #  ToStringAction()
        self.action_results: list[WriteFileResult] = []

    @property
    def action_names(self) -> list[str]:
        return [action.name for action in self.actions]

    def pre_process_data(self, data: Data) -> Data:
        for d, _ in data:
            if d.name in self.action_names:
                continue
            new_attributes = self.renderer.get_metadata_for_template(d.name, d)
            d.attrs.update(new_attributes)
        return data

    def process_data(self, data: Data) -> Optional[str]:
        try:
            for action in self.actions:
                if data.name == action.name:
                    ret, action_result = action.process_data(self, data)
                    if action_result:
                        self.action_results.append(action_result)
                    return ret
            return self.renderer.process(data)
        except MissingTemplateException as e:
            path = Path(self.config.template_directories[0]) / f"{e.name}.jinja2"
            raise RuntimeError(
                dedent(
                    f"""
                The template `{e.name}` was not found. Here's a default template to 
                get you started:
                
                {self.renderer.DEFAULT_TEMPLATE}

                ---
                at: {path}

                """
                ).strip()
            )

    def process_xml_from_filename(self, file: str) -> Optional[str]:
        struct: Data = xml_file_to_data(file)
        return self.process(struct)

    def process_action_results(self) -> None:
        for action_result in self.action_results:
            if isinstance(action_result, WriteFileResult):
                print("writing to {result.to}: '{content}'")
                with open(action_result.to, "w") as h:
                    h.write(action_result.content)
            else:
                raise RuntimeError(f"Unsupported action {action_result}")

    def process(self, data: Data) -> Optional[str]:
        return self._process(data)

    def _process(self, data: Data) -> Optional[str]:
        data = self.pre_process_data(data)
        result = self.process_data(data)
        self.process_action_results()
        return result

    @classmethod
    def from_config(
        cls,
        *,
        template_directories: list[Path],
        filters: Optional[dict[str, Callable]] = None,
    ) -> "Sal":
        config = Config(
            template_directories=template_directories, filters=filters or {}
        )

        repository = TemplateLoader.from_directories(config.template_directories)

        template_renderer = Renderer(
            repository=repository, renderer=TemplateRenderer(), filters=config.filters
        )
        return cls(config, template_renderer)
