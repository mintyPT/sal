# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_codegen.ipynb.

# %% auto 0
__all__ = ['Config', 'Sal', 'from_config']

# %% ../nbs/02_codegen.ipynb 3
# TODO Configure logging
import logging
import abc
from pydantic import BaseModel
from typing import Any, Callable
from dataclasses import dataclass
from pathlib import Path
from textwrap import dedent
from typing import Optional

from .core import Data
from .loaders import xml_file_to_data
from sal.templates import (
    Renderer,
    TemplateLoader,
    TemplateRenderer,
    MissingTemplateException,
)

# %% ../nbs/02_codegen.ipynb 12
@dataclass
class ToFile:
    to: str
    content: str


class SalAction(abc.ABC):
    @property
    @abc.abstractmethod
    def name(self) -> str:
        pass

    @abc.abstractmethod
    def process_data(self, sal: "Sal", data: Data) -> tuple[str, Optional[ToFile]]:
        pass

    def __str__(self) -> str:
        return f"action:{self.name}"


class SalListAction(SalAction):
    name = "sal-list"

    def process_data(self, sal: "Sal", data: Data) -> tuple[Any, None]:
        return [sal.process(d) for d in data.children], None

# %% ../nbs/02_codegen.ipynb 13
class Config(BaseModel):
    template_directories: list[Path]
    filters: dict[str, Callable] = {}


class Sal:
    def __init__(self, config: Config, renderer: Renderer):
        self.config = config
        self.renderer = renderer
        self.actions = [SalListAction()]  #  ToStringAction()
        self.action_results: list[ToFile] = []

    @property
    def action_names(self) -> list[str]:
        return [action.name for action in self.actions]

    def pre_process_data(self, data: Data) -> Data:
        for d, _ in data:
            if d.name in self.action_names:
                continue
            new_attributes = self.renderer.get_metadata_for_template(d.name, d)
            d.attrs.update(new_attributes)
        return data

    def process_data(self, data: Data) -> Optional[str]:
        try:

            for action in self.actions:
                if data.name == action.name:
                    ret, action_result = action.process_data(self, data)
                    if action_result:
                        self.action_results.append(action_result)
                    return ret  # type: ignore

            res: str = self.renderer.process(data)

            # TODO supposedely a child get a parents attrs so why does the child not get rendered to?
            if save := data.attrs.get("to-file"):
                self.action_results.append(ToFile(to=save, content=res))

            return res

        except MissingTemplateException as e:
            path = Path(self.config.template_directories[0]) / f"{e.name}.jinja2"
            raise RuntimeError(
                dedent(
                    f"""
                The template `{e.name}` was not found. Here's a default template to 
                get you started:
                
                {self.renderer.DEFAULT_TEMPLATE}

                ---
                at: {path}

                """
                ).strip()
            )

    def process_xml_from_filename(self, file: str) -> Optional[str]:
        struct: Data = xml_file_to_data(file)
        return self.process(struct)

    def process_action_results(self) -> None:
        for action_result in self.action_results:
            if isinstance(action_result, ToFile):
                logging.info(
                    f"Writing to {action_result.to}:\n {action_result.content}\n\n"
                )
                with open(action_result.to, "w") as h:
                    h.write(action_result.content)
            else:
                raise RuntimeError(f"Unsupported action {action_result}")

    def process(self, data: Data) -> Optional[str]:
        return self._process(data)

    def _process(self, data: Data) -> Optional[str]:
        data = self.pre_process_data(data)
        result = self.process_data(data)
        self.process_action_results()
        return result

# %% ../nbs/02_codegen.ipynb 14
def from_config(
    template_directories: list[Path],
    filters: Optional[dict[str, Callable]] = None,
) -> Sal:
    config = Config(template_directories=template_directories, filters=filters or {})

    repository = TemplateLoader.from_directories(config.template_directories)

    template_renderer = Renderer(
        repository=repository, renderer=TemplateRenderer(), filters=config.filters
    )
    return Sal(config, template_renderer)
