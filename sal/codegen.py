# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_codegen.ipynb.

# %% auto 0
__all__ = ['Config', 'Sal']

# %% ../nbs/02_codegen.ipynb 2
import abc

from pydantic import BaseModel
from typing import Any, Callable
from dataclasses import dataclass

from .core import Data
from .templates import Renderer, TemplateLoader, TemplateRenderer

# %% ../nbs/02_codegen.ipynb 11
class SalAction(abc.ABC):
    @property
    @abc.abstractmethod
    def name() -> str:
        pass

    @abc.abstractmethod
    def process_data(self, sal: "Sal", data: Data) -> str:
        pass

    def __str__(self):
        return f"action:{self.name}"


@dataclass
class WriteFileResult:
    to: str
    content: str


class ToFileAction(SalAction):
    name = "to-file"

    def process_data(self, sal: "Sal", data: Data) -> str:
        rendered = sal.renderer.render(data, template=Renderer.DEFAULT_TEMPLATE)

        if "to" not in data.attrs:
            raise RuntimeError(
                "To save to file you need to define the 'to' attribute with a filepath"
            )
        to = data.attrs["to"]

        # with open(to, "w") as h:
        #    h.write(rendered)

        return rendered, WriteFileResult(to=to, content=rendered)


class WrapperAction(SalAction):
    name = "wrapper"

    def process_data(self, sal: "Sal", data: Data) -> str:
        return [sal.process(d) for d in data.children], None

# %% ../nbs/02_codegen.ipynb 12
# TODO add support to inject more action into this
class Config(BaseModel):
    template_directories: list[str]
    filters: dict[str, Callable] = {}


class Sal:
    def __init__(self, renderer: Renderer):
        self.renderer = renderer
        self.actions = [ToFileAction(), WrapperAction()]  #  ToStringAction()
        self.action_results = []

    def pre_process_data(self, data: Data) -> Data:
        for d, _ in data:
            if d.name in self.action_names:
                continue
            # handle front matter

            if hasattr(self.renderer, "get_metadata_for_template"):
                new_attributes = self.renderer.get_metadata_for_template(d.name, d)
                d.attrs.update(new_attributes)
        return data

    def process_data(self, data: Data) -> str | Any:
        for action in self.actions:
            if data.name == action.name:
                ret, action_result = action.process_data(self, data)
                if action_result:
                    self.action_results.append(action_result)
                return ret
        return self.renderer.process(data)

    def process(self, data: Data) -> str | Any:
        data = self.pre_process_data(data)

        result = self.process_data(data)

        for action_result in self.action_results:
            if isinstance(action_result, WriteFileResult):
                print("writing to {result.to}: '{content}'")
                with open(action_result.to, "w") as h:
                    h.write(action_result.content)
            else:
                raise RuntimeError(f"Unsupported action {result}")

        return result

    @property
    def action_names(self):
        return [action.name for action in self.actions]

    # TODO support multiple template directories
    @classmethod
    def from_config(cls, config: Config):
        repository = TemplateLoader.from_directories(config.template_directories)
        template_renderer = Renderer(
            repository=repository, renderer=TemplateRenderer(), filters=config.filters
        )
        return cls(template_renderer)
